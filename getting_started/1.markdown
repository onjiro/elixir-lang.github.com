---
layout: getting_started
title: 1 はじめに
guide: 1
total_guides: 7
---

# {{ page.title }}

ようこそ！このチュートリアルでは，エリクサーを使い始める方法をお見せします．エリクサーをインストールする方法，インタラクティブシェルや基本的なデータ型と演算子の使い方から始めていきましょう．後の章で，マクロ，プロトコルやその他エリクサーが提供する機能など，より高度なテーマについてお話しします．

動いているエリクサーを見るには，Dave Thomasによる入門用スクリーンキャストを見てください．最初のものは，[Nine Minutes of Elixir](http://www.youtube.com/watch?v=hht9s6nAAx8)で，言語を簡単に一巡りしています．もう一つはあなたがエリクサーで最初の関数を書き始めるたり最初のプロセスを作成する手助けになる[introduction to Elixir](http://www.youtube.com/watch?v=a-off4Vznjs)で30分あります．あなたのマシンへエリクサーをインストールして，ビデオと一緒に進めるためには，このガイドの次のセクションに従ってください．

PeepCodeにも[Meet Elixir](https://peepcode.com/products/elixir)というJosé Valimの2時間のビデオがあります．

エリクサーはまだ開発中であるので，エラーメッセージが表示され，進める方法がわからない場合， ぜひいつでも[issues trackerで知らせてください]((https://github.com/elixir-lang/elixir/issues)．説明的で一貫性のあるエラーメッセージを持つことは，エリクサーで目指している多くの特長の中の1つです．

## 1.1 インストール

エリクサーを動かすために唯一必要なのはErlangで，バージョンR16B以降が必要です．Erlangの[ソースコード](http://www.erlang.org/download.html)，[コンパイル済みパッケージ](https://www.erlang-solutions.com/downloads/download-erlang-otp)はリンク先にあります．

Windowsで開発する人には，コンパイル済みパッケージをお勧めします．UNIXプラットフォームの場合はおそらくパッケージ管理ツールを経由してErlangをインストールできると思います．

Erlangがインストールされたら，コマンドライン（あるいはコマンドプロンプト）を開いて，erlと入力することでErlangのバージョンを確認することができるようになっているはずです．そうすると次のようにいくつか情報が表示されます:

    Erlang R16B (erts-5.10.1) [source] [64-bit] [smp:2:2] [rq:2] [async-threads:0] [hipe] [kernel-poll:false]

どうやってErlangをインストールしたかに注意してください，その方法によってはErlangのバイナリをあなたの環境(訳註:パス?)に追加しないことがあります．Erlangのバイナリが[PATH](http://en.wikipedia.org/wiki/Environment_variable)に含められていることを確認してください，そうしないとエリクサーが動きません！

Erlangの起動と実行ができるようになったなら，エリクサーのインストールに進みましょう．ディストリビューション経由，コンパイル済みパッケージ，またはソースからコンパイルしたものを使う方法があります．

### 1.1.1 ディストリビューション経由

このチュートリアルには，エリクサーv0.10.2以降が必要で，いくつかのディストリビューションではすぐに利用できます：

* Mac OS X用Homebrew
  * `brew update`してhomebrewを最新にする
  * エリクサーをインストール: `brew install elixir`
* Fedora 17+とFedora Rawhide
  * `sudo yum -y install elixir`
* Arch Linux (AURを利用)
  * `yaourt -S elixir`
* openSUSE (およびSLES 11 SP3+)
  * Erlangの開発リポジトリを追加 `zypper ar -f obs://devel:languages:erlang/ erlang`
  * エリクサーをインストール: `zypper in elixir`
* Gentoo
  * `emerge --ask dev-lang/elixir`
* Windows用Chocolatey
  * `cinst elixir`

上記のディストリビューションのいずれも使用していない場合でも，コンパイル済みパッケージを提供していますのでご心配なく！

### 1.1.2 (UnixやMinGWでの)ソースからのコンパイル

数手順でエリクサーをダウンロードしてコンパイルすることができます．[ここで最新の安定リリース]((https://github.com/elixir-lang/elixir/tags)を取得し，それを解凍し，解凍したディレクトリの中で`make`を動かしてください．そうすると，`bin`ディレクトリから`elixir`と`iex`のコマンドを実行する準備が整います．開発を容易にするために，環境変数PATHにエリクサーの`bin`のパスを追加しておくことをお勧めします:

    $ export PATH="$PATH:/path/to/elixir/bin"

もう少し冒険してみたい場合，マスターからコンパイルすることもできます:

    $ git clone https://github.com/elixir-lang/elixir.git
    $ cd elixir
    $ make clean test

テストがうまくいったなら，準備は整いました．そうならなかった場合，気軽に[GitHubのissues tracker](https://github.com/elixir-lang/elixir)に登録してください．

### 1.1.3 コンパイル済パッケージ

エリクサーは[すべてのリリースのたびにコンパイル済みパッケージ](https://github.com/elixir-lang/elixir/releases/)を提供しています ．コンパイル済みパッケージは，Windows上で開発している場合に最適なオプションとなります．

パッケージをダウンロード，解凍すると，`bin`ディレクトリから`elixir`と`iex`コマンドを実行する準備ができあがります．開発を簡単にするため，環境変数PATHにエリクサーの`bin`のパスを追加することをお勧めします．

## 1.2 インタラクティブモード

あなたがエリクサーをインストールすると，3つの実行ファイル`iex`,`elixir`と`elixirc`を得ることになります．もしあなたがソースからのコンパイルしたエリクサーやパッケージ版を使っているなら，その中にある`bin`ディレクトリから見つけだすことができます．

ここでは，`iex`(インタラクティブエリクサーの意)を実行してみましょう．インタラクティブモードでは，エリクサーのどんな式でも入力でき，そしてすぐに結果を得ることができます．いくつかの基本的な算術式でアップを始めましょう:

```iex
iex> 1 + 1
2
iex> 10 - 5
5
iex> 10 / 2
5.0
```
`10 / 2`がintegerの代わりにfloatの`5.0`を返していることに注意してください．これは期待通りの動きです．エリクサーの`/`演算子は常にfloatを返します．もし除算結果を整数で得たかったり，剰余を得たい場合は`div`と`rem`という関数を呼びだすことができます．

```iex
iex> div(10, 2)
5
iex> div 10, 2
5
iex> rem 10, 3
1
```

上の例では`div`と`rem`という2つの関数を呼び出しました．関数を呼びだすのに括弧が必要でないことに注意してください．後でこのことについて詳しく話します．先に進んで，他にエリクサーがどんなデータ型を持っているか見てみましょう．

## 1.3 基本的な型

いくつかの基本的な型は以下の通りです:

```iex
iex> 1          # integer
iex> 0x1F       # integer
iex> 1.0        # float
iex> :atom      # atom / symbol
iex> {1,2,3}    # tuple
iex> [1,2,3]    # list
iex> <<1,2,3>>  # bitstring
```

エリクサーはこれらの型で動作する沢山の関数をデフォルトでインポートしています:

```iex
iex> size { 1, 2, 3 }
3

iex> length [ 1, 2, 3 ]
3
```

エリクサーはUTF-8でエンコードされたstringもサポートしています:

```iex
iex> "hellö"
"hellö"
```

stringのinterpolation(訳注:#{}による文字列の補完)もサポートしています:

```iex
iex> name = "world"
iex> "hello #{name}"
"hello world"
```

実のところ，stringはバイト列をまとめたものに過ぎません．`is_binary`関数で確かめることができます:

```iex
iex> is_binary("hello")
true
iex> byte_size("hello")
5
```

そしてバイナリはビット列をまとめたものに過ぎません:

```iex
iex> is_bitstring("hello")
true
iex> bit_size("hello")
40
```

エリクサーではあなたが生のバイナリを作ることできます．3つのnullバイトで構成されたバイナリを作ってみましょう:

```iex
iex> is_binary <<0, 0, 0>>
true
```

エリクサーでは，シングルクォートされた式はcharのリストで，ダブルクォートされたものと同じではないことに注意してください:

```iex
iex> is_binary('hello')
false
iex> is_list('hello')
true
```

charのリストについては次の章で詳しく触れます．エリクサーはbooleanとして`true`と`false`も提供しています:

```iex
iex> true
true
iex> is_boolean false
true
```

boolean値は内部ではatomとして表されています:

```iex
iex> is_atom(true)
true
```

エリクサーは匿名関数も提供しています(匿名関数を呼び出す場合の値と引数の間にあるドットに注意してください):

```iex
# function
iex> x = fn(a, b) -> a + b end
#Fun<erl_eval.12.111823515>
iex> x.(1, 2)
3
```

エリクサーはデータ型として`Port`,`Reference`や`PID`も提供しています(通常はプロセス間通信で利用されます)，しかしこれらは導入を目的としたチュートリアルの範囲からは外れています．今のところは，次の章へ進む前にエリクサーの基本的な演算子を見てみましょう．

## 1.4 演算子

これまで見てきたように，エリクサーは算術演算子として`+`,`-`,`*`,`/`を提供しています．

エリクサーはリストの操作のために`++`と`--`も提供しています:

```iex
iex> [1,2,3] ++ [4,5,6]
[1,2,3,4,5,6]
iex> [1,2,3] -- [2]
[1,3]
```

stringの連結は`<>`を通して行われます:

```iex
iex> "foo" <> "bar"
"foobar"
```

エリクサーは3つのboolean演算子:`or`, `and` and `not`を提供しています．これらの演算子は最初の引数にboolean(`true`か`false`)を期待するという意味で厳密です:

```iex
iex> true and true
true
iex> false or is_atom(:example)
true
```

booleanではないものを与えると例外を発生させます:

```iex
iex> 1 and true
** (ArgumentError) argument error
```

`or`と`and`はショートサーキット演算子です．左側の結果が条件を満たせないことが決まった場合のみ右側が実行されます:

```iex
iex> false and error("This error will never be raised")
false

iex> true or error("This error will never be raised")
true
```

> メモ: もしあなたがErlang開発者なら，エリクサーの`and`と`or`は実際にはErlangの`andalso`と`orelse`に対応しています．

これらのboolean演算子の他に，エリクサーはどんな型の引数も受け入れ可能な`||`,`&&`と`!`を提供しています．これらの演算子は`false`と`nil`以外の全てをtrueと評価します．

```iex
# or
iex> 1 || true
1
iex> false || 11
11

# and
iex> nil && 13
nil
iex> true && 17
17

# !
iex> !true
false
iex> !1
false
iex> !nil
true
```

おおまかに言うと，boolean値を期待しているなら`and`,`or`や`not`を使います．boolean値ではないものを引数にするなら`&&`,`||`や`!`を使います．

エリクサーは比較演算子として`==`,`!=`,`===`,`!==`,`<=`,`>=`,`<`や`>`も提供しています:

```iex
iex> 1 == 1
true
iex> 1 != 2
true
iex> 1 < 2
true
```

`==`と`===`の違いは，後者の方がintegerとfloatと比較した場合により厳密であるということです:

```iex
iex> 1 == 1.0
true
iex> 1 === 1.0
false
```

エリクサーでは2つの異なるデータ型を比較できます:

```iex
iex> 1 < :atom
true
```

2つの異なるデータ型を比較できるのは，実用のためです．ソートアルゴリズムはソートする場合に異なるデータ型のことを心配する必要がありません．全体の並び順は以下のようになっています:

    number < atom < reference < functions < port < pid < tuple < list < bitstring

正確にこの順番を記憶しておく必要はありませんが，こういった順番があることを知っておくことは重要です．

はい，ここまでが導入です．次の章では基本的な関数，データ型の変換とちょっとした制御フローについて話しましょう．
