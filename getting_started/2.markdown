---
layout: getting_started
title: 2 Diving in
guide: 2
total_guides: 7
---

# {{ page.title }}

この章ではデータ型をもう少し詳しく知ったり，いくつかの制御フローについて学んだり，匿名関数について話したりします．

## 2.1 listとtuple

エリクサーはlistとtupleのどちらも提供します:

 ```iex
iex> is_list [1,2,3]
true
iex> is_tuple {1,2,3}
true
```

どちらも物を収めるのに使われます，違いはどうやってメモリに物を収めるかです．listはlinked lists(リストの中の物が，次の物の場所を指し示している)で実装されているのに対しtupleは連続したメモリに収められています．

つまり，tupleの要素にアクセスするのはとても速く(定数時間)，`elem`関数を使って行なえます:

 ```iex
iex> elem { :a, :b, :c }, 0
:a
 ```

一方，tupleの更新はメモリにあるtupleの内容を複製しなければならないので，高くつきます．tupleの更新は`set_elem`関数で行えます:

```iex
iex> set_elem { :a, :b, :c }, 0, :d
{:d,:b,:c}
 ```

> メモ: もしあなたがErlangの開発者なら，Erlangの`element`と`setelement`関数のかわりに`elem`と`set_elem`関数を使ったと気づくでしょう．関数の最初の引数が常に主体となる，0から始まるアクセスができるようにするといった，ErlangのAPIを標準化するElixirの試みのためにこのようにしました．

tupleを更新するのはたいへんなので，要素を追加あるいは削除したい場合はlistを使います．リストはリンクしているので，最初の要素にアクセスするのはとても簡単です．N番目の要素にアクセスするには，どうやってもN番目にたどりつくまでにN-1のノードを通る計算になります．以下のようにlistの`head`へアクセスできます:

```iex
# Match the head and tail of the list
iex> [head | tail] = [1,2,3]
[1,2,3]
iex> head
1
iex> tail
[2,3]

# Put the head and the tail back together
iex> [head | tail]
[1,2,3]
iex> length [head | tail]
3
```

上記のように，listの先頭を変数`head`へ当て，listの残りを変数`tail`へ当てることができます．これを**パターンマッチング**といいます．tupleにもパターンマッチできます:

```iex
iex> { a, b, c } = { :hello, "world", 42 }
{ :hello, "world", 42 }
iex> a
:hello
iex> b
"world"
```

パターンマッチはマッチしなかった時にエラーになります．tupleが違うサイズだった場合の例です:

```iex
iex> { a, b, c } = { :hello, "world" }
** (MatchError) no match of right hand side value: {:hello,"world"}
```

異なる型を比較した場合です:

```iex
iex> { a, b, c } = [:hello, "world", '!']
** (MatchError) no match of right hand side value: [:hello,"world",'!']
```

最も興味深いのは，特定の値にマッチさせることができることです．次の例は，右側がタプルで，キーとして`:ok`というatomから始まるものだけを受けつけるということを，左側の部分で指定しています:

```iex
iex> { :ok, result } = { :ok, 13 }
{:ok,13}
iex> result
13

iex> { :ok, result } = { :error, :oops }
** (MatchError) no match of right hand side value: {:error,:oops}
```

パターンマッチングを使うとlistやtupleのようなデータ型を簡単に解体できるようになります．これは後の章で紹介する，エリクサーで再帰を扱う際の基本の一つとなります．しかし，そこまでlistの反復処理をするのが待ちきれないとおっしゃるなら，[`Enum` module](/docs/stable/Enum.html)がlist(や，他に一般的に列挙できるもの)の操作のヘルパーをいくつか提供しており，また[`List` module](/docs/stable/List.html)でも特にlistに特化した操作のヘルパーをいくつか提供しています．

```iex
iex> Enum.at [1,2,3], 0
1
iex> List.flatten [1,[2],3]
[1,2,3]
```

## 2.2 キーワードリスト

エリクサーはキーワードのリストを作るための特別な構文を提供しています．以下のようにして作れます:

```iex
iex> [a: 1, b: 2]
[a: 1, b: 2]
```

キーワードリストは単に最初の要素がatomである二要素のtupleをまとめたlistでしかありません．

 ```iex
iex> [head | tail] = [a: 1, b: 2]
[a: 1, b: 2]
iex> head
{ :a, 1 }
```

[`Keyword` module](/docs/stable/Keyword.html)はキーワードリストの操作で重複を無視するか，無視しないかといった操作をするためのいくつかの関数を保持しています．例えば:

 ```iex
iex> keywords = [foo: 1, bar: 2, foo: 3]
iex> Keyword.get keywords, :foo
1
iex> Keyword.get_values keywords, :foo
[1,3]
```

キーワードリストは引数として渡すことが多いので，関数呼び出しの最後の引数として渡す場合は角括弧を不要としています．例えば以下の例はどれも正しくて，かつ同じ内容を表しています:

```iex
iex> if(2 + 2 == 4, [do: "OK"])
"OK"
iex> if(2 + 2 == 4, do: "OK")
"OK"
iex> if 2 + 2 == 4, do: "OK"
"OK"
```

## 2.3 string(バイナリ)とchar list(リスト)

エリクサーにおいて，ダブルクォートされた値はシングルクォートされた値とは異なります:

```iex
iex> "hello" == 'hello'
false
iex> is_binary "hello"
true
iex> is_list 'hello'
true
```

ダブルクォートされた値は**string**でバイナリで表現されています．シングルクォートされた値は**char list**でlistで表現されています．

事実，ダブルクォートされたものとシングルクォートされたものはそれぞれ単にバイナリとリストの短い表現にすぎません．エリクサーで`?a`を与えられると`a`のASCII値を返します，そこでこのように書けます:

```iex
iex> is_integer ?a
true
iex> <<?a, ?b, ?c>>
"abc"
iex> [?a, ?b, ?c]
'abc'
```

このケースでは，エリクサーはバイナリの中やリストの中の全ての文字が表示可能であることを検出してクォートで表現しています．しかし，表示可能ではない文字を追加すると，表示が変わります:

```iex
iex> <<?a, ?b, ?c, 1>>
<<97,98,99,1>>

iex> [?a, ?b, ?c, 1]
[97,98,99,1]
```

エリクサーでは，明示的にcharのリストが必要な場合(エリクサーからErlangのインターフェースでたまに使います)ではないときはダブルクォートされたstringの方が良いです．リストもバイナリのどちらもパターンマッチングできます:

```iex
iex> <<a, b, c>> = "foo"
"foo"
iex> a
102
```

バイナリの"tail"をマッチさせることもできます，最初の1バイトを抽出してマッチさせて，残りをバイナリにするには:

```iex
iex> <<f :: integer, rest :: binary>> = "foo"
"foo"
iex> f
102
iex> rest
"oo"
```

上記の例では，バイナリの各セグメントにタグをつけました．最初のセグメントはinteger型(デフォルト)で，文字"f"のASCIIコードを取得します．残りのバイト"oo"はバイナリとして`rest`に割り当てられます．

エリクサーのバイナリ/ビット文字構文はとてもパワフルで，バイト，ビット，UTF8コードポイント単位などでのマッチができます．詳しくは[in Elixir docs](http://elixir-lang.org/docs/master/Kernel.SpecialForms.html#<<>>/1)でみることができます．次はユニコードについて話しましょう．

## 2.4 ユニコードのサポート

エリクサーのstringはUTF-8でエンコードされたバイナリになっています．例えばstring "é" は2バイトのバイナリです:

```iex
iex> string = "é"
"é"
iex> size(string)
2
```

stringを簡単に操作するために，エリクサーは[`String` モジュール](http://elixir-lang.org/docs/stable/String.html)を提供しています:

```iex
# returns the number of bytes
iex> size "héllò"
7

# returns the number of characters as perceived by humans
iex> String.length "héllò"
5
```

> メモ: データ構造の要素数を調べるのに，`length`と`size`という関数を使います．これらは任意に使い分けられるのではありません．前者は要素の数を計算しなければならない場合に使われます．例えば，`length(list)`を呼ぶとリストの要素数を知るのにリスト全体の要素を反復します．対して`size`はあらかじめ計算されてどこかに格納されているので軽い処理で値を求めることができます．つまりバイナリのサイズを手に入れるためには軽い`size`を使います，しかしユニコードの文字数を知るには，string全体を反復して調べる必要があるために`String.length`を使います．

string "héllò" の中の各文字はユニコードエンドポイントです．`String.codepoints`を使うとstringをコードポイント毎に分割した小さなstringにできます．

```iex
iex> String.codepoints "héllò"
["h", "é", "l", "l", "ó"]
```

ユニコード標準は各文字に対して整数を割り当てています．エリクサーでは以下のように整数のコードポイントを元に文字を調べたり挿入したりできます:

```iex
# Getting the integer codepoint
iex> ?h
104
iex> ?é
233

# Inserting a codepoint based on its hexadecimal value
iex> "h\xE9ll\xF2"
"héllò"
```

UTF-8はパターンマッチングもうまくできます．以下の例は，stringの最初のUTF-8コードポイントを抽出して，残りのstringを`rest`に割り当てています:

```iex
iex> << eacute :: utf8, rest :: binary >> = "épa"
"épa"
iex> eacute
233
iex> << eacute :: utf8 >>
"é"
iex> rest
"pa"
```

一般的に，エリクサーでバイナリとstringを扱うのは簡単です．もしもっと生々しいバイナリをいじりたくなった場合，[Erlang's binary module](http://www.erlang.org/doc/man/binary.html)を使うこともできますし，UTF-8でエンコードされたstringとして扱いたいなら[Elixir's String module](http://elixir-lang.org/docs/stable/String.html)を使うことができます．

## 2.5 ブロック

たいてい最初に学ぶフロー制御構造は`if`条件です．エリクサーでも以下のように`if`を書けます:

```iex
iex> if true, do: 1 + 2
3
```

`if`式はブロック構文を使っても書けます:

```iex
iex> if true do
...>   a = 1 + 2
...>   a + 10
...> end
13
```

`do`/`end`ブロックについて，式のまとまりを`:do`へ渡すための便利な方法を考えることもできます．これは以下と同じです:

```iex
iex> if true, do: (
...>   a = 1 + 2
...>   a + 10
...> )
13
```

ブロック構文の中で`else`節を渡すこともできます:

```elixir
if false do
  :this
else
  :that
end
```

`do`/`end`は常に一番遠い関数呼び出しにバインドされることに気をつけることが大事です．例えば，次の式

```elixir
is_number if true do
  1 + 2
end
```

は次のように解析されます:

```elixir
is_number(if true) do
  1 + 2
end
```

この場合の`is_number`のように，一番遠い関数呼び出しにバインドされることを望まない場合，明示的に括弧を追加することであいまいさを解決できます:

```elixir
is_number(if true do
  1 + 2
end)
```

## 2.6 フロー制御構造

この節ではエリクサーの主なフロー制御構造について詳しくみていきます．

### 2.6.1 パターンマッチング再び

この章の最初にいくつかのパターンマッチングの例をみました:

```iex
iex> [h | t] = [1,2,3]
[1, 2, 3]
iex> h
1
iex> t
[2, 3]
```

エリクサーにおいて，Java,Ruby,Pythonなど他のプログラミング言語とは違い，`=`は代入演算子ではありません．`=`は正確に言うと，左辺と右辺の式がマッチしてるかを調べるマッチ演算子です．

エリクサーの多くのフロー制御構造は，パターンマッチングと，異なる節をマッチさせられる能力を大きく利用しています．いくつかの場合，変数の値にマッチさせたいことがあります，その時は`^`演算子を使うと参照専用とすることができます．

```iex
iex> x = 1
1
iex> ^x = 1
1
iex> ^x = 2
** (MatchError) no match of right hand side value: 2
iex> x = 2
2
```

エリクサーでは，使おうと考えていない値は`_`に割り当てることがよく行われています．例えば，もしリストの先頭にだけ興味がある場合，残りにはアンダースコアを割り当てます:

```iex
iex> [h | _] = [1,2,3]
[1, 2, 3]
iex> h
1
```

エリクサーでの変数`_`は特別で，絶対にどこからも読まれることがありません．読もうとすると unbound variable error になります:

```iex
iex> _
** (ErlangError) erlang error {:unbound_var, :_}
```

パターンマッチングは強力なのですが，使用方法に制限があります．例えば，マッチの左側で関数呼び出しをすることができません．以下の例はうまくいきません:

```iex
iex> length([1,[2],3]) = 3
** (ErlangError) erlang error :illegal_pattern
```

### 2.6.2 ケース

`case`は複数のパターンからいずれかがマッチするまでの比較をすることができます:

```elixir
case { 1, 2, 3 } do
  { 4, 5, 6 } ->
    "This won't match"
  { 1, x, 3 } ->
    "This will match and assign x to 2"
  _ ->
    "This will match any value"
end
```

`=`演算子と同様に，変数はmatch節で割り当てられた値で上書きされることがあります．もし変数に対してパターンマッチしたい場合には，`^`演算子を使う必要があります．

```elixir
x = 1
case 10 do
  ^x -> "Won't match"
  _  -> "Will match"
end
```

それぞれのmatch節にガード経由で期待している条件を書くことができます:

```elixir
case { 1, 2, 3 } do
  { 4, 5, 6 } ->
    "This won't match"
  { 1, x, 3 } when x > 0 ->
    "This will match and assign x"
  _ ->
    "No match"
end
```

上の例だと，xが正の場合2番目の節のみがマッチします．Erlang VMではガードとして使える式を限定して許可しています:

* 比較演算子(`==`, `!=`, `===`, `!==`, `>`, `<`, `<=`, `>=`);
* ブール演算子(`and`, `or`)と否定演算子(`not`, `!`);
* 算術演算子(`+`, `-`, `*`, `/`);
* `<>`と`++`の左側がリテラルのもの;
* `in`演算子;
* 以下の全ての型チェック関数(スラッシュのあとの数は引数の数を表しています):

    * is_atom/1
    * is_binary/1
    * is_bitstring/1
    * is_boolean/1
    * is_float/1
    * is_function/1
    * is_function/2
    * is_integer/1
    * is_list/1
    * is_number/1
    * is_pid/1
    * is_port/1
    * is_record/1
    * is_record/2
    * is_reference/1
    * is_tuple/1
    * is_exception/1

* 加えてこれらの関数:

    * abs(Number)
    * bit_size(Bitstring)
    * byte_size(Bitstring)
    * div(Number, Number)
    * elem(Tuple, n)
    * float(Term)
    * hd(List)
    * length(List)
    * node()
    * node(Pid|Ref|Port)
    * rem(Number, Number)
    * round(Number)
    * self()
    * size(Tuple|Bitstring)
    * tl(List)
    * trunc(Number)
    * tuple_size(Tuple)

複数の独立したガード節を同時に渡すこともできます．例えば，tupleかlistの最初の要素が0であるかどうかチェックする関数について考えてみましょう．以下のように書くことができます:

```elixir
def first_is_zero?(tuple_or_list) when
  elem(tuple_or_list, 0) == 0 or hd(tuple_or_list) == 0 do
  true
end
```

しかし，上記の例は常に失敗します．もし引数がlistなら，`elem`をリストに対して呼び出してエラーが発生します．もし要素がtupleなら，`hd`をtupleに対して呼び出すとエラーが発生します．これを直すため，2つの異った節となるように書き直します:

```elixir
def first_is_zero?(tuple_or_list)
    when elem(tuple_or_list, 0) == 0
    when hd(tuple_or_list) == 0 do
  true
end
```

こうすると，ガードの一つがエラーになっても，次のガードには影響しません．

### 2.6.3 関数

エリクサーでは，匿名関数が複数の節とガードを受けつけ，先程見た`case`に似た形式になります:

```elixir
f = fn
  x, y when x > 0 -> x + y
  x, y -> x * y
end

f.(1, 3)  #=> 4
f.(-1, 3) #=> -3
```
v
Elixir はイミュータブルな言語であるので，関数のバインディングもイミュータブルです． これは，関数の内側で設定した変数は，関数の外側には影響を及ぼさないことを意味しています:

```elixir
x = 1
(fn -> x = 2 end).()
x #=> 1
```

### 2.6.4 受信

次のフロー制御構造はエリクサーのactorにとって欠くことのできないものです．エリクサーでは，コードは別々のプロセスで動作し，それぞれにメッセージを交換します．それらのプロセスはOSのプロセスではありません(とても軽いです)が，お互いに状態を共有しないのでこう呼ばれています．

メッセージを交換するため，各プロセスは受信したメッセージを貯めておけるメールボックスというものを持っています．`receive`で与えられたパターンに合致するメッセージを探しにいくことができるようになります．以下は矢印演算子`<-`を使ってメッセージを現在のプロセスへ送り，メールボックスからそのメッセージを収集する例です:

```iex
# 現在のプロセスIDを取得します
iex> current_pid = self

# 現在のプロセスIDへメッセージを送る，別のプロセスを生成します
iex> spawn fn ->
  current_pid <- { :hello, self }
end
<0.36.0>


# メッセージを集めます
iex> receive do
...>   { :hello, pid } ->
...>     IO.puts "Hello from #{inspect(pid)}"
...> end
Hello from <0.36.0>
```

もしかしたら`<0.36.0>`が戻ってこないことがあるかもしれませんが，何か似たものがくるはずです．もしメールボックスにメッセージがない場合，after節を与えられていなければ，今のプロセスはメッセージがくるまで止まります．

```iex
iex> receive do
...>   :waiting ->
...>     IO.puts "This may never come"
...> after
...>   1000 -> # 1 second
...>     IO.puts "Too late"
...> end
Too late
```

`spawn`関数へ引数として別の関数を渡して新しいプロセスを生成したことに注目してください．後の章でこれらのプロセスのことや異なるノード間でのメッセージの交換についてお話しします．

### 2.6.5 Try

エリクサーでは`try`は投げられた値を受けとるのに使われます．例をみてみましょう:

```iex
iex> try do
...>   throw 13
...> catch
...>   number -> number
...> end
13
```

`try/catch`はコードが複雑な出口戦略を持っており，スタックから値を戻すのに`throw`を使った方が簡単，という珍しい状況で役に立つフロー制御機構です．`try`では`catch`の中でガードが使え，値をキャッチしたかどうかにかかわらず呼び出される`after`節も使えます:

```iex
iex> try do
...>   throw 13
...> catch
...>   nan when not is_number(nan) -> nan
...> after
...>   IO.puts "Didn't catch"
...> end
Didn't catch
** throw 13
    erl_eval:expr/3
```

投げられた値を誰も受け取らなかった場合にソフトウェアが停止してしまうことに注意してください．こういった理由から，Elixirはこの節は安全でないと考えていて(うまくいくかもしれないし，失敗するかもしれないため)`try/catch/after`の中の変数に外側のスコープからアクセスすることはできません:

```iex
iex> try do
...>   new_var = 1
...> catch
...>   value -> value
...> end
1
iex> new_var
** (UndefinedFunctionError) undefined function: IEx.Helpers.new_var/0
```

一般的なやり型としては`try`からの値を引数として明示的に全て返します:

```elixir
{ x, y } = try do
  x = calculate_some_value()
  y = some_other_value()
  { x, y }
catch
  _ -> { nil, nil }
end

x #=> returns the value of x or nil for failures
```

### 2.6.6 IfとUnless

上にあげたような主だったフロー制御構造の他に，日々の仕事の助けになるようなフロー制御構造がいくつかあります．例えば`if`と`unless`です:

```iex
iex> if true do
iex>   "This works!"
iex> end
"This works!"

iex> unless true do
iex>   "This will never be seen"
iex> end
nil
```

エリクサーでは`do/end`ブロックは単なるキーワード表記のショートカットであることを思いだしてください． ですから以下のようにも書けます:

```iex
iex> if true, do: "This works!"
"This works!"
```

もっと複雑な例ですと:

```elixir
# This is equivalent...
if false, do: 1 + 2, else: 10 + 3

# ... to this
if false do
  1 + 2
else
  10 + 3
end
```

エリクサーでは`false`と`nil`以外の全ての値がtrueと評価されます．つまり`if`の引数を明示的にブーリアンへ変換しなくてもかまいません．もし複数の条件のうちいずれかがtrueであることをチェックしたい場合，`cond`マクロを使うことができます．

### 2.6.7 Cond

一度に複数の条件をチェックしたい場合，エリクサーでは複数の`if`式を入れ子にするかわりに`cond`を使うことができます:

```elixir
cond do
  2 + 2 == 5 ->
    "This will never match"
  2 * 2 == 3 ->
    "Nor this"
  1 + 1 == 2 ->
    "But this will"
end
```

もしどの条件もtrueにならなかった場合，エラーが発生します．そのため，通常は条件の最後が`true`になるようにして，常にマッチするようにします:

```elixir
cond do
  2 + 2 == 5 ->
    "This will never match"
  2 * 2 == 3 ->
    "Nor this"
  true ->
    "This will always match (equivalent to else)"
end
```

## 2.7 組み込み関数

エリクサーは現在のスコープで沢山の組み込み関数を自動的に使えるように用意しています．上で見たようなフロー制御式に加え，tupleの中の値を読み書きするのに`elem`や`set_elem`，与えられたデータ型をバイナリで表現するのに`inspect`，などなどです．これらの関数は[`Kernel`](/docs/stable/Kernel.html)や[Elixir special forms are available in `Kernel.SpecialForms`](/docs/stable/Kernel.SpecialForms.html)にあり，デフォルトでインポートされています．

これらの関数とフロー制御式はエリクサーでのプログラミングに欠かせないものです．いくつかの場合Erlangにある関数を使う必要があるかもしれません，その方法を見てみましょう．

## 2.8 Erlangの関数を呼びだす

既にあるErlangのエコシステムとの統合が簡単であることがエリクサーの資産の一つです．ErlangはOTP(Open Telecom Platform)と呼ばれるライブラリ群を出しています．標準ライブラリに加え，OTPは堅牢，分散，フォールトトレラントなOTPアプリケーションをスーパーバイザーと共に構築する機能を提供します．

Erlangのモジュールはatomそのものなため，エリクサーからそれらを呼び出すのはすぐにできます．例えば，[`lists`モジュールから`flatten`関数](http://www.erlang.org/doc/man/lists.html#flatten-1)を呼んだり[`math`モジュール](http://www.erlang.org/doc/man/math.html)と触れあったりというのは以下のようにできます:

```iex
iex> :lists.flatten [1,[2],3]
[1,2,3]
iex> :math.sin :math.pi
1.2246467991473532e-16
```

ErlangのOTPはとでも良く文章化されており，私たちは後に出てくるMixの章でOTPアプリケーションの構築方法について学びます．

* [OTP docs](http://www.erlang.org/doc/)
* [Standard library docs](http://www.erlang.org/doc/man/STDLIB_app.html)

今回はここまでです．次の章では，異なるアプリケーションから簡単にコードを再利用できるようにするためのモジュールへのまとめ方を話していきます．
