---
layout: getting_started
title: 4 レコード，プロトコル & 例外
guide: 4
total_guides: 7
---

# {{ page.title }}

エリクサーはレコードとプロトコルを提供しています．この章ではその2つについて概要をお知らせしつつ，いくつかの例を見ていきます．特に`defmacro`，`defprotocol`そして`defimpl`をどのように使うかを学びます．そして最後に少しだけエリクサーの例外について話します．

## 4.1 レコード

レコードは値を保持するシンプルな構造です．例えば`FileInfo`レコードはファイルの情報を以下のように保持します:

```elixir
defrecord FileInfo, atime: nil, accesses: 0
```

上の行では新しいレコードを返す`new`という名前の関数と，値を読み書きする関数を持った`FileInfo`という名前のモジュールを定義します:

```iex
iex> file_info = FileInfo.new(atime: { 2010, 4, 17 }, accesses: 42)
iex> file_info.atime
{2010, 4, 17}
iex> file_info.atime({ 2012, 10, 13 }) #=> Returns a new FileInfo
FileInfo[atime: {2012, 10, 13}, accesses: 42]
iex> file_info.atime
{2010, 4, 17}
```

レコードの`atime`フィールドを変更した場合，自分達で`file_info`へ再保存することを忘れないでください．これは，エリクサーの他のほぼ全てのものと同じように，レコードもイミュータブルであるためです．そのため`atime`フィールドの変更はレコード内には反映されません．そのかわり，新しい値がセットされた，新しいレコードが返ります．

レコードは単に最初の要素がレコードのモジュール名であるタプルです．以下のようにしてレコードの未加工な表現を取得できます:

```elixir
inspect FileInfo.new, raw: true
#=> "{ FileInfo, nil, 0 }"
```

エリクサーのレコードは各属性の読み書きを定義するだけでなく，`update_#{attribute}`関数による値の更新も定義します．この関数は引数として現在の値を受けとり，新しい値を必ず返す関数を求めます．例えばファイルにアクセスされるたび，アクセスカウンターを増加させるのは:

```elixir
file_info = FileInfo.new(accesses: 10)
file_info = file_info.update_accesses(fn(x) -> x + 1 end)
file_info.accesses #=> 11
```

### 4.1.1 パターンマッチング

エリクサーはレコードに対してもパターンマッチできます．例えば，さきほど書いた`FileInfo`レコードを利用して，ファイルアクセスがあったか，あるいはなかったかを調べたいとすると，以下のように実装できます:

```elixir
defmodule FileAccess do
  def was_accessed?(FileInfo[accesses: 0]), do: false
  def was_accessed?(FileInfo[]),            do: true
end
```

最初の節は`FileInfo`レコードが与えられて，その`accesses`フィールドが0のときにだけマッチします．二番目の節はどんな`FileInfo`レコードにもマッチします．`access`の値を変数に結びつけるのに以下のような書き方もできます:

```elixir
def was_accessed?(FileInfo[accesses: accesses]), do: accesses > 0
```

パターンマッチング構文は新しいレコードを作るのにも使えます:

```elixir
file_info = FileInfo[accesses: 0]
```

上のように角括弧構文を使うとき，エリクサーはコンパイルのときにそのレコードをタプルに展開します．つまり，先ほど挙げた節は:

```elixir
def was_accessed?(FileInfo[accesses: 0]), do: false
```

以下と同じ意味になります:

```elixir
def was_accessed?({ FileInfo, _, 0 }), do: false
```
角括弧構文は強力で，パターンマッチングに使えるだけでなく，パフォーマンスについても`FileInfo.new`して`file_info.accesses`するのに比べて速くなります．欠点はレコード名をハードコードすることです．そのため，エリクサーでは両方のスタイルを混ぜて，場合に応じてうまくいきそうな方を使うことができます．

レコードについてさらに詳しい内容は[`defrecord`マクロのマニュアルを見てください](http://elixir-lang.org/docs/master/Kernel.html#defrecord/3)

## 4.2 プロトコル

プロトコルはエリクサーでポリモーフィズムを実現するためのメカニズムです．あるプロトコルを実装したデータ型であれば，そのプロトコルで処理できます．実際の例で考えてみましょう．

エリクサーでは，`false`と`nil`だけがfalseとなります．その他の全てはtrueと評価されます．アプリケーションによっては，ブランクとみなせるデータ型でブール値を返す`blank?`プロトコルを表したいことがあるでしょう．例えば空リストや空バイナリはブランクとみなせます．

このプロトコルは以下のように定義できます:

```elixir
defprotocol Blank do
  @doc "Returns true if data is considered blank/empty"
  def blank?(data)
end
```

このプロトコルは一つの引数を取る`blank?`関数を実装することを期待しています．以下のようにいくつかのデータ型にこのプロトコルを実装できます:

```elixir
# Integers are never blank
defimpl Blank, for: Integer do
  def blank?(_), do: false
end

# Just empty list is blank
defimpl Blank, for: List do
  def blank?([]), do: true
  def blank?(_),  do: false
end

# Just the atoms false and nil are blank
defimpl Blank, for: Atom do
  def blank?(false), do: true
  def blank?(nil),   do: true
  def blank?(_),     do: false
end
```

最初からあるデータ型全てに対して同じようにできます．以下のデータ型があります:

* `Record`
* `Tuple`
* `Atom`
* `List`
* `BitString`
* `Integer`
* `Float`
* `Function`
* `PID`
* `Port`
* `Reference`
* `Any`

今，プロトコルが定義されていて，それに対する実装をしているなら，呼び出すことができます:

```elixir
Blank.blank?(0)       #=> false
Blank.blank?([])      #=> true
Blank.blank?([1,2,3]) #=> false
```

プロトコルを実装していないデータ型を渡すとエラーを発生させるので注意してください:

```iex
iex> Blank.blank?("hello")
** (UndefinedFunctionError) undefined function: Blank.BitString.blank?/1
```

### 4.2.1 Fallback to any

いくつかの場合，全ての型に対してデフォルトの実装を提供した方が便利な場合があります．これはプロトコル定義の中で`@fallback_to_any`を`true`に設定するとできます:

```elixir
defprotocol Blank do
  @fallback_to_any true
  def blank?(data)
end
```

こうすると以下のように実装できます:

```elixir
defimpl Blank, for: Any do
  def blank?(_), do: false
end
```

今，`Blank`プロトコルを実装していない全てのデータ型はブランクではないとみなせます．

### 4.2.2 プロトコルをレコードと一緒に使う

エリクサーの拡張性はプロトコルとレコードが混在しているところからきています．

例えば，エリクサーは沢山のキーの保持を効率的に行えるデータ構造`HashDict`の実装を提供しています．どんな風に動くのかちょっと見てみましょう:

```elixir
dict = HashDict.new
dict = HashDict.put(dict, :hello, "world")
HashDict.get(dict, :hello) #=> "world"
```

この`HashDict`を調べてみると，単純なタプルを見ることができます:

```elixir
inspect(dict, raw: true)
#=> { HashDict, 1, [{:hello,"world"}] }
```

`HashDict`は複数の値を含むデータ構造であるうえ，`Blank`プロトコルを簡単に実装するのにも便利です:

```elixir
defimpl Blank, for: HashDict do
  def blank?(dict), do: HashDict.size(dict) == 0
end
```

そしてこのようにテストできます:

```elixir
dict = HashDict.new(hello: "world")
Blank.blank?(dict)         #=> false
Blank.blank?(HashDict.new) #=> true
```

すばらしい！既にあるデータ構造(`HashDict`)へ，ラップしたり再コンパイルせずに`Blank`プロトコルを実装しましたね，これで過去に定義済のプロトコルを簡単に拡張することができます．プロトコルを定義したときにサポート対象のリストに`Record`を追加していた場合にのみ，このような動作をすることに注意してください:

```elixir
@only [Atom, Record, Tuple, List, BitString, Any]
```

`Record`は`Tuple`からできていることを覚えておいてください．全てのレコードはタプルです(しかし，全てのタプルはレコードではありません)．この理由により，与えられたプロトコルの実装をレコードがしていない場合．そのプロトコルのタプルでの実装があれば，エリクサーはそれを代わりに使います．ですから，単にタプルへ実装を定義するだけで，簡単に全てのレコードに対してのデフォルト実装を追加することができます．

### 4.2.3 組み込みプロトコル

エリクサーはいくつかの組み込みプロトコルを同梱しています．そのうちのいくつかをみていきます:

* `Access` - どうやって要素にアクセスするかを表しています．エリクサーにおいて角括弧を用いてアクセスができるようにします．例えば:

```iex
iex> x = [a: 1, b: 2]
[{:a, 1}, {:b, 2}]
iex> x[:a]
1
iex> x[:b]
2
```

* `Enumerable` - 列挙できるなら，どんなデータ構造でもこのプロトコルを実装しなければなりません．このプロトコルは`Enum`モジュールによって提供される`map`や`reduce`などの関数で使われます:

```iex
iex> Enum.map [1,2,3], fn(x) -> x * 2 end
[2,4,6]
iex> Enum.reduce 1..3, 0, fn(x, acc) -> x + acc end
6
```

* `Binary.Inspect` - このプロトコルはあらゆるデータ構造から読むことができるテキスト表現への変換に使われます．IExのようなツールで結果を表示するのに使っています:

```iex
iex> { 1, 2, 3 }
{1,2,3}
iex> HashDict.new
#HashDict<[]>
```

  検査された値は`#`から始まるということを覚えておいてください，これはエリクサーのデータ構造の構文表現としては正しくありません．それを満たす表現は`raw`をオプションに指定して`inspect`を直接呼び出すと得られます:

```iex
iex> inspect HashDict.new, raw: true
"{HashDict,0,[]}"
```

* `String.Chars` - どうやって文字の並びを文字列に変換するかを表しています．これは`to_string`関数を介して公開されています:

```iex
iex> to_string :hello
"hello"
```

  エリクサーでの文字列の補完は`to_string`関数を呼んでいることに注意してください:

```iex
iex> "age: #{25}"
"age: 25"
```

  上の例は数値が`String.Chars`プロトコルを実装しているので動きます．例えばタプルを渡すとエラーになるでしょう:

```iex
iex> tuple = {1, 2, 3}
{1, 2, 3}
iex> "tuple: #{tuple}"
** (Protocol.UndefinedError) protocol String.Chars not implemented for {1, 2, 3}
```

  もっと複雑なデータ構造を"print"したくなった場合，単に`inspect`関数を使うのが簡単です:

```iex
iex> "tuple: #{inspect tuple}"
"tuple: {1, 2, 3}"
```

エリクサーのドキュメントに書いてある他のプロトコルも使えます．フレームワークやライブラリにある，定義されたプロトコルも同様に使えます．保守や拡張を簡単にするため，それらを賢く使ってコードを書いていきましょう．

## 4.3 例外

例外処理は多くの言語で独自の章を持つほどでしょうけれども，ここでの役割は少なめです．

例外は`try`ブロックの中で`rescue`キーワードを使うと拾えます:

```elixir
# rescue only runtime error
try do
  raise "some error"
rescue
  RuntimeError -> "rescued"
end

# rescue runtime and argument errors
try do
  raise "some error"
rescue
  [RuntimeError, ArgumentError] -> "rescued"
end

# rescue and assign to x
try do
  raise "some error"
rescue
  x in [RuntimeError] ->
    # all exceptions have a message
    x.message
end
```

`rescue`と例外名にはガードもパターンマッチングも使えないことに注意してください．この制限は意図的なものです: 開発者はソフトウェアを動かすために例外を使うべきではありません．実際に，**エリクサーの例外は例外的な状況でのみ使われるべきです**．

例えば，ログのパーティショニングとローテーションをネットワーク越しに行うソフトウェアでは，ネットワークの問題やファイルシステムにアクセスした場合に不安定になることが起こり得ます．このソフトウェアにとって，これらのシナリオは例外的なものではなく，うまく合わせて処理しなければなりません．したがって，このソフトウェアではいくつかのファイルを`File.read`を使って読みこみ，結果をマッチさせます:

```elixir
case File.read(file) do
  { :ok, contents }  ->
    # We were able to access the file
    # Proceed as expected
  { :error, reason } ->
    # Oops, something went wrong
    # We need to handle the error accordingly
end
```

`File.read`が何かうまくいかなない場合に例外を発生させないことに注意してください;成功した場合には`{ :ok, contents }`，失敗の場合には`{ :error, reason }`を含んだタプルを返します．これにより，私たちのアプリケーションがどのように振る舞うべきか,エリクサーのパターンマッチングを組み合せて制御できます．

一方，ユーザーによって指定されたファイルにアクセスしたり扱ったりするCLIインターフェースでは必ずファイルがあることを前提とすることがあります．もしファイルがなければ，何もしないのではなく，失敗させたいですね．その場合例外を発生させる`File.read!`を使うことができます:

```iex
iex> contents = File.read!("/inexistent/file")
** (File.Error) could not read file /inexistent/file: no such file or directory
```

このパターンはエリクサーの標準ライブラリーに共通で，多くのライブラリーはどちらの形式も提供しています．

最後になりますが，例外は`defrecord`に似たAPI`defexception`で定義されている単なるレコードです．しかし，エリクサーではそれを控えめにしか使わないことを覚えておいてください．

例外を制御フローのために使わないエリクサーの哲学を紹介しています．もしコードが動くようにするために例外をrescueしなればならないと感じたなら，たぶん，そのかわりにアトムかタプルといったパターンマッチングできるようなものを返すべきです．

次に，`defmacro`と`defmacrop`を使い，マクロを構築して，エリクサーがどのように生産性に立ち向かっているか見ていきましょう!

>注意: Erlangとの統合を容易にするため，エリクサーでは，Erlangでも動作するように`try/catch`を使った場合に来る"catching errors"を取り扱えるようになっています:
>
>
>     try do
>       :erlang.error(:oops)
>     catch
>       :error, :oops ->
>         "Got Erlang error"
>     end
>
>
> 最初のアトムは`:error`，`:throw`か`:exit`のいずれかになります．エリクサーでは例外の救出をすることだけが推奨されていることを忘れないでください．
