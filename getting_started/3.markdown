---
layout: getting_started
title: 3 モジュール
guide: 3
total_guides: 7
---

# {{ page.title }}

エリクサーでは，いくつかの機能をモジュールにまとめることができます．例えば前章では，私たちは[`List`モジュール](/docs/stable/List.html)の関数を呼び出しました:

```iex
iex> List.flatten [1,[2],3]
[1, 2, 3]
```

エリクサーで独自のモジュールを作成するために，行わなければならないことは`defmodule`関数を呼び出すことと`def`関数を関数の定義に使うことです:

```iex
iex> defmodule Math do
...>   def sum(a, b) do
...>     a + b
...>   end
...> end

iex> Math.sum(1, 2)
3
```

モジュールに入る前に，最初にコンパイルについての簡単な概要を掴んでみましょう．

## 3.1 コンパイル

コンパイルや再利用ができるようになるため，たいていの場合はモジュールをファイルに書く方が便利です．`math.ex`というファイルに以下の内容が書かれているとしましょう:

```elixir
defmodule Math do
  def sum(a, b) do
    a + b
  end
end
```

このファイルは，`elixirc`を使用してコンパイルすることができます(あなたがパッケージからエリクサーをインストールしたり，コンパイルしてインストールした場合，`elixirc`はbinディレクトリの中にあることを思い出してください):

    elixirc math.ex

そうすると定義されたモジュールをバイトコードとして含む`Elixir.Math.beam`という名前のファイルが生成されます． さて，`iex`を再び起動すると，私たちが定義したモジュールが使えるようになります(`iex`は同じディレクトリにバイトコードファイルがあると起動しておくように考慮されています):

```iex
iex> Math.sum(1, 2)
3
```

エリクサープロジェクトは通常，3つのディレクトリで編成されています:

* ebin - コンパイルされたバイトコードが含まれています
* lib - エリクサーのコードが含まれています(通常は`.ex`ファイル)
* test - テスト-テストが含まれています(通常は`.exs`ファイル)

既存のライブラリと対話するときは，バイトコードを探せるようにエリクサーに明示的に`ebin`ディレクトリの場所を伝える必要があります:

    iex -pa ebin

`-pa`は`path append`の略です．同じオプションを`elixir`や`elixirc`に渡すこともできます．`elixir`や`elixirc`に引数を渡さずに実行すると，オプションの一覧を取得できます．

## 3.2 スクリプトモード

エリクサーは`.ex`形式のファイルに加えて ，スクリプト用として`.exs`形式にも対応しています．エリクサーは，両方のファイルをまったく同じように扱い，唯一の違いは，どのように扱うかという意図です．`.ex`ファイルはコンパイルされ，`.exs`ファイルは，コンパイルを必要とせずに，スクリプトとして利用されます．例えば，`math.exs`と呼ばれるファイルを作成してみます:

```elixir
defmodule Math do
  def sum(a, b) do
    a + b
  end
end

# IO.puts expects a list or a binary, so we use the string representation of the sum
IO.puts to_string(Math.sum(1, 2))
```

そしてそれを実行します:

    elixir math.exs

ファイルはメモリ上でコンパイルされて実行され，結果として"3"と表示します．バイトコードファイルは作成されません．

## 3.3 関数とプライベート関数

モジュール内では，`def`で関数を，`defp`でプライベートな関数を定義することができます．`def`で定義された関数は他のモジュールから呼び出すことが可能です．プライベートな関数はローカルでのみ呼び出すことができます．

```elixir
defmodule Math do
  def sum(a, b) do
    do_sum(a, b)
  end

  defp do_sum(a, b) do
    a + b
  end
end

Math.sum(1, 2)    #=> 3
Math.do_sum(1, 2) #=> ** (UndefinedFunctionError)
```

関数の宣言において，ガードと複数の節をサポートしています．関数にいくつかの節がある場合，エリクサーはマッチする節を見つけるまでそれぞれの節を試していきます．与えられた数がゼロであるかどうかをチェックする関数の実装は，次のとおりです:

```elixir
defmodule Math do
  def zero?(0) do
    true
  end

  def zero?(x) when is_number(x) do
    false
  end
end

Math.zero?(0)  #=> true
Math.zero?(1)  #=> false

Math.zero?([1,2,3])
#=> ** (FunctionClauseError)
```

どの節にもマッチしない引数を与えた場合エラーが発生します．

名前付き関数はデフォルト引数もサポートしています．

```elixir
defmodule Concat do
  def join(a, b, sep // " ") do
    a <> sep <> b
  end
end

IO.puts Concat.join("Hello", "world")      #=> Hello world
IO.puts Concat.join("Hello", "world", "_") #=> Hello_world
```

デフォルト値を提供するためにどんな式を用意してもかまいませんが，関数の定義時には評価されず，後から使用する場合に備えて保存されます．デフォルト値を使わなければならない関数が呼び出されるたびに，保存された，デフォルト値を提供するための式が評価されます:

```elixir
defmodule DefaultTest do
  def dowork(x // IO.puts "hello") do
    x
  end
end
```

```iex
iex> DefaultTest.dowork 123
123
iex> DefaultTest.dowork
hello
:ok
```

デフォルト値を持つ関数が複数の節を持っている場合，単にデフォルトを宣言するだけのための，ボディ部分無しの独立したdef文を作成することをお勧めします:

```elixir
defmodule Concat do
  def join(a, b // nil, sep // " ")

  def join(a, b, _sep) when nil?(b) do
    a
  end

  def join(a, b, sep) do
    a <> sep <> b
  end
end

IO.puts Concat.join("Hello", "world")      #=> Hello world
IO.puts Concat.join("Hello", "world", "_") #=> Hello_world
IO.puts Concat.join("Hello")               #=> Hello
```

デフォルト値を使用する場合，関数の定義が重複しないように注意しなければなりません．次の例を考えてみます:

```elixir
defmodule Concat do
  def join(a, b) do
    IO.puts "***First join"
    a <> b
  end

  def join(a, b, sep // " ") do
    IO.puts "***Second join"
    a <> sep <> b
  end
end
```

"concat.ex"という名前のファイルで上記のコードを保存し，それをコンパイルする場合，エリクサーは次の警告を出します:

    concat.ex:7: this clause cannot match because a previous clause at line 2 always matches

コンパイラは，2 つの引数の`join`の場合，常に最初の定義が選ばれ，2番目の`join`が呼び出されるのは 3 つの引数の場合のみであると告げています:

    $ iex concat.ex

```iex
iex> Concat.join "Hello", "world"
***First join
"Helloworld"
```

```iex
iex> Concat.join "Hello", "world", "_"
***Second join
"Hello_world"
```

### 3.4 再帰

不変性のため，エリクサー(や関数型プログラミング言語)でのループは従来の命令型言語とは異なる書き方をされています．例えば，命令型言語では，次のように記述します:

```c
for(i = 0; i < array.length; i++) {
  array[i] = array[i] * 2
}
```

上記の例では，エリクサーではできない，配列の変更をしています．そのため，関数型言語では，再帰(条件に達するまで関数が再帰的に呼び出される)に頼ります．以下のような，手動でリスト内のすべての項目を合計する例を考えてみましょう:

```elixir
defmodule Math do
  def sum_list([h|t], acc) do
    sum_list(t, h + acc)
  end

  def sum_list([], acc) do
    acc
  end
end

Math.sum_list([1,2,3], 0) #=> 6
```

上記の例では，リスト`[1,2,3]`と，初期値`0`を引数として与えて`sum_list`を呼び出しています．関数に複数の節がある場合，パターンマッチングルールに基づいてマッチするものを見つけられるまで，それぞれの節を試していきます．この場合だと，`acc`は0に設定されて，リスト`[1,2,3]`は`[h|t]`にマッチし，`h = 1`と`t = [2,3]`へ割り当てられます．

その後，`h + acc`でリストの先頭をアキュムレータに追加し，引数としてリストの残りを渡して，再び，再帰的に`sum_list`を呼び出します．以下のようにリストが空になるまで，リストの残りは再び`[h|t]`へのマッチを繰り返します:

```elixir
sum_list [1,2,3], 0
sum_list [2,3], 1
sum_list [3], 3
sum_list [], 6
```

リストが空である場合，最後の節とマッチし，最終的な結果`6`を返します．命令型言語では，このような実装をすると，(実行してきた経路が保持されている)スタックが制限に到達するまで成長してしまうため，大きなリストとなりたいてい失敗します．しかし，エリクサーでは，関数が終了する際に別の関数を呼び出すことでスタックが成長しない，末尾呼び出し最適化が行われます．

再帰と末尾呼び出しの最適化はエリクサーの重要な一部であり，ループを作成するため，特にプロセスがメッセージを待つ必要がある場合に頻繁に利用されます(前の章で`receive`マクロを使うのを見ましたね)．しかし，[Enumモジュール](/docs/stable/Enum.html)がすでにそのようなユースケースを抽象化しているため，上記のような再帰はリストを操作するためにはほとんど使用されていません．例えば，上記の例は，単に次のように記述できます:

```elixir
Enum.reduce([1,2,3], 0, fn(x, acc) -> x + acc end)
```

## 3.5 ディレクティブ

ソフトウェアの再利用を容易にするため，エリクサーは，3つのディレクティブをサポートしています．以下を見ていくとわかるように，それらは**レキシカルスコープ**を持っているので，ディレクティブと呼ばれています．

### 3.5.1 alias

`alias`で任意のモジュールに別名をつけることができます．`Math`モジュールには数学の操作を行うための特別なリストがあると想像して下さい:

```elixir
defmodule Math do
  alias Math.List, as: List
end
```

ここから，全ての`List`への参照は自動的に`Math.List`へ展開されます．元の`List`へアクセスしたい場合には，`Elixir`モジュールを介してアクセスすることができます:

```elixir
List.values             #=> uses Math.List.values
Elixir.List.values      #=> uses List.values
Elixir.Math.List.values #=> uses Math.List.values
```

> 注:エリクサーで定義されているすべてのモジュールはエリクサー名前空間内に定義されています．しかし，利便性のために，エリクサー名前空間は省略することができます．

`as`オプションなしの`alias`呼び出しは自動的にモジュール名の最後の部分をエイリアスを設定します，たとえば:

```elixir
alias Math.List
```

は以下と同じです:

```elixir
alias Math.List, as: List
```

`alias`は**レキシカルスコープ**であることに注意してください，それが特定の関数内でエイリアスを設定することを可能にしています:

```elixir
defmodule Math do
  def add(a, b) do
    alias Math.List
    # ...
  end

  def minus(a, b) do
    # ...
  end
end
```

上記の例では，`add`関数の内部で`alias`が呼び出されているので，エイリアスは単に`add`関数内でのみ有効となります．`minus`は全く影響を受けません．

### 3.5.2 require

一般的に，対象のモジュールにあるマクロを使用する場合を除き，使用する前にrequireする必要はありません．例えば，私たちが`MyMacros`という名前のモジュールの中に`my_if`という実装を作ったとします．もしそれを呼び出したい場合，私たちは最初に`MyMacros`を明示的にrequireする必要があります:

```elixir
defmodule Math do
  require MyMacros
  MyMacros.my_if do_something, it_works
end
```

ロードされていないマクロを呼ぼうとすると，エラーが発生します．`alias`ディレクティブのように，`require`もまたレキシカルスコープであることに注意してください．第5章でマクロについてさらに詳しく話します．

### 3.5.3 import

修飾名を使用せずに，他のモジュールの関数やマクロにアクセスしたいときに`import`を使います．例えば，モジュールの中で`List`の`duplicate`関数を複数回使いたく，毎回`List.duplicate`と打ち込みたくない場合，簡単にインポートできます:

```elixir
defmodule Math do
  import List, only: [duplicate: 2]

  def some_function do
    # call duplicate
  end
end
```

このケースでは，`List`から(引数2つの)`duplicate`関数だけをインポートしています．`only:`はオプションではありますが，使うことが推奨されています．他にオプションとして`except`も指定することができます．

`import`はインポートしたい対象をフィルタリングする，セレクタをサポートしています．4つのセレクタがあります:

* `:default` - _で始まるものを除く，すべての関数とマクロをインポートする;
* `:all` - すべての関数とマクロをインポートする;
* `:functions` - すべての関数をインポートする;
* `:macros` - すべてのマクロをインポートする;

たとえば，すべてのマクロをインポートするには，次のように書くことができます:

```elixir
import MyMacros, only: :macros
```

あるいはすべての関数をインポートするには，次のように書くことができます:

```elixir
import MyFunctions, only: :functions
```

`import`も**レキシカルスコープ**であることに注意してください，これは私たちが特定の関数内で特定のマクロをインポートすることができることを意味します:

```elixir
defmodule Math do
  def some_function do
    import List, only: [duplicate: 2]
    # call duplicate
  end
end
```

上の例では，インポートされた`List.duplicate`はそれを指定した関数内でのみ見ることができます．`duplicate`はモジュール内の他の関数では利用できなくなります(他のモジュールの場合についても同じことがいえます)．

モジュールをインポートすると，自動的にそれが必要になることに注意してください．さらに，別名をつけられるようにするため，`import`は，`alias`へ自動的に渡される`as:`オプションを用意しています．

## 3.6 モジュールの属性

エリクサーはErlangからモジュール属性という概念をもってきました．たとえば次のようなものです:

```elixir
defmodule MyServer do
  @vsn 2
end
```

上記の例では，私たちは明示的にそのモジュールのバージョン属性を設定しています．`@vsn`は，ErlangのVM内のコード再読み込み機構が，モジュールが更新されたかどうかをチェックするために使用されます．もしバージョンが指定されていない場合は，モジュール関数をMD5チェックサムしたものがバージョンとして設定されます．

エリクサーは，少数の予約属性を持っています．ここではそれらのほんの一部であり，最も一般的に使用されるものを見ていきます．サポートされている属性の完全なリストについては[Module](http://elixir-lang.org/docs/stable/Module.html)のドキュメントを見て下さい．

* `@moduledoc` - 現在のモジュールのドキュメントを提供します;
* `@doc` - 属性の下に書かれる関数やマクロのドキュメントを提供しています;
* `@behaviour` -  (つづりが英国式であることに注意してください)OTPまたはユーザー定義の動作を指定するために使われます;
* `@before_compile` - モジュールがコンパイルされる前に呼び出されるフックが用意されています．これにより，コンパイルの直前にモジュール内へ関数を注入することができます．

次の属性は[typespecs](http://www.erlang.org/doc/reference_manual/typespec.html)の一部で，エリクサーでもサポートされています:

* `@spec` - 関数の仕様を提供します;
* `@callback` - behaviorコールバックのための仕様を提供します;
* `@type` - `@spec`で使用する型を定義します;
* `@typep` - `@spec`で使用するプライベートな型を定義します;
* `@opaque` - `@spec`で使用する不透明な型(opaque type)を定義します;

上記でざっと見た組み込み属性に加え，カスタム属性も追加することができます:

```elixir
defmodule MyServer do
  @my_data 13
  IO.inspect @my_data #=> 13
end
```

エリクサーにおいて，一時的にデータを格納するためにユーザ定義された属性を使用することはよくあるので，Erlangとは異なり，ユーザ定義された属性は，デフォルトではモジュールに格納されていません．開発者は，[`Module.register_attribute/3`](/docs/stable/Module.html#register_attribute/3)を呼び出して属性をErlangの振舞いに似た動作をするようにも設定できます．

最後に，属性は関数の内側で読むことができることに着目してください:

```elixir
defmodule MyServer do
  @my_data 11
  def first_data, do: @my_data
  @my_data 13
  def second_data, do: @my_data
end

MyServer.first_data #=> 11
MyServer.second_data #=> 13
```

関数内で属性を読み取ると，現在の値のスナップショットを取得していることに注意してください．言い換えると，この値は実行時ではなく，コンパイル時に読み込まれます．モジュール属性を操作するためのその他の関数については[`Module`モジュールのドキュメント](/docs/stable/Module.html)を見てください．

## 3.7 ネスト

エリクサーのモジュールもネストすることができます:

```elixir
defmodule Foo do
  defmodule Bar do
  end
end
```

上記の例では，`Foo`と`Foo.Bar`という2つのモジュールを定義します．二つめのモジュールは，同じスコープ内にある限り，`Foo`の内側では`Bar`としてアクセスすることができます．後に開発者が`Bar`を別のファイルに移動することを決めた場合，完全な名前(`Foo.Bar`)によって参照するか，前述した`alias`ディレクティブを使用して別名を設定する必要があります．

## 3.8 エイリアス

Erlangでは(つまり，ErlangのVMでも)，モジュールや関数はアトムで表されます．例えば，これは有効なErlangのコードです:

```elixir
Mod = lists,
Mod:flatten([1,[2],3]).
```

上記の例では，変数`Mod`に`lists`というアトムを保存し，次に関数`flatten`が呼び出されます．エリクサーでも，同じ表現ができます:

```iex
iex> mod = :lists
:lists
iex> mod.flatten([1,[2],3])
[1,2,3]
```

言い換えると，私たちは単に`:lists`アトムの`flatten`を呼び出しているだけです．まさにこのメカニズムこそが，エリクサーのエイリアスに力を与えています．エリクサーでのエイリアスは(`List` ，`Keyword`などの)頭文字が大文字化された識別子で，これらはコンパイルのときにモジュールを表すアトムに変換されます．例えば，`List`というエイリアスはデフォルトでは`Elixir.List`というアトムになります:

```iex
iex> is_atom(List)
true
iex> to_binary(List)
"Elixir.List"
```
