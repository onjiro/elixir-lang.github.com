---
layout: getting_started
title: 5 マクロ
guide: 5
total_guides: 7
---

# {{ page.title }}

Elixirでは自身の構造を自身で表現できます．この章ではそれらの構造がどういった形で見えるか，また，その構造を，あなたが作ったマクロからどうやって操作するかについて詳しくみていきます．

## 5.1 エリクサープログラムの構成要素

エリクサーは3要素のタプルで構成されています．Elixirでは`sum(1,2,3)`の関数呼び出しは以下のように表現されます:

```elixir
{ :sum, [], [1, 2, 3] }
```

`quote`マクロを使うことでどんな式の表現でも取得することができます:

```iex
iex> quote do: sum(1, 2, 3)
{ :sum, [], [1, 2, 3] }
```

演算子もタプルで表現されています:

```iex
iex> quote do: 1 + 2
{ :+, [], [1, 2] }
```

タプルも`{}`を呼びだすことで表現されています:

```iex
iex> quote do: { 1, 2, 3 }
{ :{}, [], [1, 2, 3] }
```

変数もタプルを使うことで表現されています．ただし，最後の要素はリストではなくアトムになります:

```iex
iex> quote do: x
{ :x, [], Elixir }
```

もっと複雑な式をクォートする場合，各ノードがタプルとなっている，入れ子になった木構造で，それぞれの木構造はお互いに似た形をしたタプルの集まりとして表現されます．

```iex
iex> quote do: sum(1, 2 + 3, 4)
{ :sum, [], [1, { :+, [], [2, 3] }, 4] }
```

通常，上でみた通り，ノード(タプル)毎のフォーマットは以下のようになります:

```elixir
{ tuple | atom, list, list | atom }
```

* タプルの1番目の要素は，アトムか同じ表現の別のタプル;
* タプルの2番目の要素は，メタデータのリスト．ノードの行番号などを保持する;
* タプルの3番目の要素は，関数の呼び出しのための引数のリストかアトム．アトムの場合，このタプルは変数を表現している．

上に書いたノード定義の他に，クォートされたときに（タプルではなく）自身を返すエリクサーのリテラルが5つあります．それらは

```elixir
:sum         #=> Atoms
1.0          #=> Numbers
[1,2]        #=> Lists
"binaries"   #=> Strings
{key, value} #=> Tuples with two elements
```

これらの基礎構造を心に留めておけば，自分達でマクロを定義できそうです．

## 5.2 自分達のマクロを定義する

マクロは`defmacro`を使って定義されます．例えば`if`と逆のことをする`unless`というマクロをわずか数行で定義することができます:

```elixir
defmodule MyMacro do
  defmacro unless(clause, options) do
    quote do: if(!unquote(clause), unquote(options))
  end
end
```

`if`と同様に，`unless`は`clause`と`options`という2つの引数を期待しています:

```elixir
require MyMacro
MyMacro.unless var, do: IO.puts "false"
```

しかし，`unless`はマクロなので，その引数は呼び出されたときに評価されるのではなくそのまま渡されます．例えば，このように呼び出すと:

```elixir
unless 2 + 2 == 5, do: call_function()
```

`unless`マクロは以下のように受け取ります:

```elixir
unless({:==, [], [{:+, [], [2, 2]}, 5]}, { :call_function, [], [] })
```

そして`unless`マクロは`if`節の木表現を返すために`quote`を呼び出します．つまり`unless`を`if`へ変換していることになります！

式をクォートした場合によくある失敗は，開発者が`unquote`してふさわしい式にするのを忘れてしまうことです．`unquote`が何をしているか知るために消してみます:

```elixir
defmacro unless(clause, options) do
  quote do: if(!clause, options)
end
```

`unless 2 + 2 == 5, do: call_function()`のように呼ぶと，`unless`は何もせずに返します:

```elixir
if(!clause, options)
```

現在のスコープにはclauseとoptionsという変数が定義されていないので失敗します．`unquote`を戻すと:

```elixir
defmacro unless(clause, options) do
  quote do: if(!unquote(clause), unquote(options))
end
```

`unless`はこんな形で返します:

```elixir
if(!(2 + 2 == 5), do: call_function())
```

別の言い方をすると，`unquote`とはクォートされた木構造へ式を差し込む方式で，メタプログラミングをするのに欠かせない要素です．エリクサーではそれとは別に`unquote_splicing`という複数の式を一度に差し込む方法も提供しています．

マクロは望むように定義することができます．エリクサーがあらかじめ提供しているマクロでさえも例外ではなく，上書きすることができます．例えば`case`, `receive`, `+`などを再定義することができます．Elixirのスペシャルフォームだけは例外的に上書きできません．[スペシャルフォームの全一覧は`Kernel.SpecialForms`にあります](/docs/stable/Kernel.SpecialForms.html).

## 5.3 マクロの健全さ

エリクサーのマクロは決定を遅らせます．これにより，クォートの中で定義された変数は，マクロ展開後のコンテキストにある変数と競合しないことが保証されています．例えば:

```elixir
defmodule Hygiene do
  defmacro no_interference do
    quote do: a = 1
  end
end

defmodule HygieneTest do
  def go do
    require Hygiene
    a = 13
    Hygiene.no_interference
    a
  end
end

HygieneTest.go
# => 13
```

上の例にあるように，マクロが`a = 1`を挿入しても，`go`関数によって定義されている`a`には影響しません．明示的にコンテキストに影響を与えたい場合は`var!`を使うことができます．

```elixir
defmodule Hygiene do
  defmacro interference do
    quote do: var!(a) = 1
  end
end

defmodule HygieneTest do
  def go do
    require Hygiene
    a = 13
    Hygiene.interference
    a
  end
end

HygieneTest.go
# => 1
```

エリクサーがコンテキストの中の変数に注釈をつけているので，変数は健全に保たれています．例えば，モジュールの3行目で変数`x`が定義されているとき，このように表現されます:

    { :x, [line: 3], nil }

一方クォートされた変数はこのようになります:

```elixir
defmodule Sample do
  def quoted do
    quote do: x
  end
end

Sample.quoted #=> { :x, [line: 3], Sample }
```

クォートされた変数の3番目の要素は，`nil`ではなく`Sample`というアトムであることに注目してください．これは変数が`Sample`モジュール由来であることを表しています．2つの変数は違うコンテキストから来ているので，別々のものとして扱います．

似た仕組みがimportやaliaseにもあります．そのため，マクロはマクロ対象のモジュールと競合せず，マクロが書かれているモジュールの仕様で動けることが保証されています．

## 5.4 プライベートマクロ

`defmacrop`でプライベートマクロを作ることもできます．プライベートな関数と同じように，定義されたモジュールの中でコンパイルのときしか使えません．プライベートマクロの一般的な使いかたとして，同じモジュール内でガード節を頻繁に定義する場合があります:

```elixir
defmodule MyMacros do
  defmacrop is_even?(x) do
    quote do
      rem(unquote(x), 2) == 0
    end
  end

  def add_even(a, b) when is_even?(a) and is_even?(b) do
    a + b
  end
end
```

マクロは使う場所より前で定義することが大切です．使う前に定義されていない場合，マクロが展開されず，関数呼び出しとみなされて実行時エラーが発生します:

```elixir
defmodule MyMacros do
  def four, do: two + two
  defmacrop two, do: 2
end

MyMacros.four #=> ** (UndefinedFunctionError) undefined function: two/0
```

## 5.5 コードの実行

マクロについての話の最後となりますが，コードがエリクサーの中でどのように実行されるかをお話します．コードの実行は2つの段階を経て完了します．

1) コードの中の全てのマクロが再帰的に展開される;

2) 展開されたコードがErlangのバイトコードへコンパイルされ実行される

私たちがコードの構造をどう捉えるかに影響するため，この振舞いについて理解していることが重要です．以下のコードについて考えてみましょう:

```elixir
defmodule Sample do
  case System.get_env("FULL") do
    "true" ->
      def full?(), do: true
    _ ->
      def full?(), do: false
  end
end
```

上のコードは*コンパイル時に*環境変数`FULL`の値によってtrueかfalseを返す関数`full?`を定義しています．このコードを順序立てて動かしてみると，エリクサーは最初に全てのマクロを展開します．`defmodule`や`def`について考えてみると，これらもマクロなのでコードは次のように展開されます:

```elixir
:elixir_module.store Sample, fn ->
  case System.get_env("FULL") do
    "true" ->
      :elixir_def.store(Foo, :def, :full?, [], true)
    _ ->
      :elixir_def.store(Foo, :def, :full?, [], false)
end
```

このコードは実行されたとき，モジュール`Foo`の定義と環境変数`FULL`の値を元にした適切な関数を記憶します．これはErlangで書かれたエリクサーの内部モジュール`:elixir_module`と`:elixir_def`を使って行なわれます．

この例から次へ進むための2つ課題があります:

1) `case`分岐に実行時に絶対に通らない部分があるとしても，マクロは常に展開されます;

2) モジュール内で関数やマクロを定義された後でも呼び出すことができません．例えばこのようなケース:

```elixir
defmodule Sample do
  def full?, do: true
  IO.puts full?
end
```

  この例は以下のように解釈されるので失敗します:

```elixir
:elixir_module.store Sample, fn ->
  :elixir_def.store(Foo, :def, :full?, [], true)
  IO.puts full?
end
```

モジュールが定義されるとき，モジュールには名前が`full?`の関数が**まだ**定義されていないため，`IO.puts full?`でコンパイルが失敗します．

## 5.6 マクロ書くべからず

マクロは強力な構成体であるにもかかわらず，マクロクラブの最初のルールは**マクロ書くべからず**です．マクロは普通の関数に比べると書くのが大変で，必要がないのに使うのは筋が悪いと考えられています．あなたが毎日書くようなコードへのうまい解決方法は既に提供されています．マクロは最後の手段としてとっておくべきです．

これらの戒めを最後にしてマクロの紹介は終わりです．次の章でドキュメンテーションや部分的なアプリケーション，その他のちょっとしたトピックについて話しましょう．
